using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis.Text;

namespace Bshox.Generator.Helpers;

/// <remarks>
/// Modified copy of
/// <see href="https://github.com/dotnet/runtime/blob/5ab200cd23f23baefc2d7189bf721075400fb7f2/src/libraries/Common/src/SourceGenerators/SourceWriter.cs"/>
/// </remarks>
internal sealed class SourceWriter
{
    private const char IndentationChar = ' ';
    private const int CharsPerIndentation = 4;
    private const char BadNewLine = '\r';
    private const char NewLine = '\n';
    private const string Header = """
        // <auto-generated />
        #nullable enable
        #pragma warning disable

        using bsx = global::Bshox;


        """;

    internal static bool disableComments;

    private readonly StringBuilder _sb = new(Header, 2048);

    public int Indentation
    {
        get;
        set
        {
            Debug.Assert(value >= 0, "value >= 0");
            field = value;
        }
    }

    public void OpenScope()
    {
        WriteLine('{');
        Indentation++;
    }

    public void CloseScope()
    {
        Indentation--;
        WriteLine('}');
    }

    private void WriteLine(char value)
    {
        Debug.Assert(value != BadNewLine, "value != BadNewLine");
        AddIndentation();
        _ = _sb.Append(value);
        WriteLine();
    }

    [Conditional("DEBUG")]
    private static void CheckLineBreaks(string text)
    {
        Debug.Assert(!text.Contains(BadNewLine), "source contains wrong line break");
    }

    [Conditional("DEBUG")]
    public void WriteComment(string comment)
    {
        CheckLineBreaks(comment);
        Debug.Assert(!comment.Contains(NewLine), "comment contains a line break");
        if (disableComments)
            return;
        AddIndentation();
        _ = _sb.Append("// ").Append(comment).Append(NewLine);
    }

    public void WriteLine(string text)
    {
        CheckLineBreaks(text);
        if (Indentation == 0)
        {
            _ = _sb.Append(text).Append(NewLine);
            return;
        }

        bool isFinalLine;
        ReadOnlySpan<char> remainingText = text.AsSpan();
        do
        {
            ReadOnlySpan<char> nextLine = GetNextLine(ref remainingText, out isFinalLine);

            AddIndentation();
            AppendSpan(nextLine);
            WriteLine();
        }
        while (!isFinalLine);
    }

    public void WriteLine() => _sb.Append(NewLine);

    public SourceText ToSourceText()
    {
        Debug.Assert(Indentation == 0 && _sb.Length > 0, "Indentation == 0 && _sb.Length > 0");
        string text = _sb.ToString();
        CheckLineBreaks(text);
        return SourceText.From(text, Encoding.UTF8);
    }

    private void AddIndentation()
        => _sb.Append(IndentationChar, CharsPerIndentation * Indentation);

    private static ReadOnlySpan<char> GetNextLine(ref ReadOnlySpan<char> remainingText, out bool isFinalLine)
    {
        if (remainingText.IsEmpty)
        {
            isFinalLine = true;
            return default;
        }

        ReadOnlySpan<char> rest;

        int lineLength = remainingText.IndexOf(NewLine);
        if (lineLength == -1)
        {
            lineLength = remainingText.Length;
            isFinalLine = true;
            rest = default;
        }
        else
        {
            rest = remainingText.Slice(lineLength + 1);
            isFinalLine = false;
        }

        if (((uint)lineLength > 0) && (remainingText[lineLength - 1] == BadNewLine))
        {
            Debug.Fail("source contains a return-carriage character");
            lineLength--;
        }

        ReadOnlySpan<char> next = remainingText.Slice(0, lineLength);
        remainingText = rest;
        return next;
    }

    private unsafe void AppendSpan(ReadOnlySpan<char> span)
    {
        fixed (char* ptr = span)
        {
            _ = _sb.Append(ptr, span.Length);
        }
    }
}
